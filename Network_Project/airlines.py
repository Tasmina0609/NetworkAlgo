# -*- coding: utf-8 -*-
"""Network_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VnbuxGArXkQirxtRb-M0iMol6Ed_ETW8

# **Network and Algorithms Final Project**
---
Report has been attached or the link to view the report in Overleaf:
https://www.overleaf.com/read/nkmvzftwvzxb

---
*Submitted by:*
*   Naila Ibrahimova
*   Parsha Joarder 
*   Javid Mammadli

#### **Imports**
"""

import numpy as np
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

"""## **Analysis of data**

#### **Loading dataset**
"""

airports = pd.read_csv('airports.csv') # reading csv file

"""Dataset containing many flight routes ( 50000 rows Ã— 12 columns )"""

airports # view the dataset

"""#### **Creating the networkX graph from the list of edges**

Manipulating and visualizing graphs with NetworkX
"""

""" 
constructing the list of edges representing our graph,
where nodes are airports, and 
two airports are connected if there exists a route between them (flight network):
"""
G = nx.from_pandas_edgelist(airports, 'Origin', 'Dest', ['Distance'], create_using=nx.DiGraph) 
fig, ax = plt.subplots(1, 1, figsize=(15, 15))
nx.draw_networkx(G, ax=ax, node_color="red",node_size=100, alpha=1,width=.4, with_labels=False)

"""Alternative representation of the data in a graph with labels"""

Gair = nx.from_pandas_edgelist(airports, source='Origin', target='Dest', edge_attr=['Distance'],create_using=nx.DiGraph)
fig=plt.figure(figsize=(15,15))
nx.draw_networkx(Gair, with_labels=True,node_color='yellow',node_size=400,width=.2,font_size=10)

print(airports.data())

"""*Graph's statistics:*
There are 64 airports and 822 routes in the dataset.

## **Convert graph to dictionary to apply the Routing algorithms**
"""

'''
convert graph to dictioinary
keys are the nodes
values are dictionaries consisting from the neigbours and the weights betweeen node and its neigbour
'''
def convertGraphToDictionary(G, attr):
  list_of_nodes=G.nodes()  
  graph={}
  for node in list_of_nodes:
    list_of_neighbors=list(G.neighbors(node))
    dictionary={}
    for l in list_of_neighbors:
      dictionary[l]=G.edges[node, l][attr]
    graph[node]=dictionary
  return graph

"""### **Breadth-First Search**"""

def bfs_shortest_path(graph, start, goal):
  # explored nodes
  explored = []
  # all the paths to be checked
  queue = [[start]]

  # return path if start is goal
  if start == goal:
    return "Start = goal"

  # while queue is not empty
  while queue:
    # pop the first element from the queue
    path = queue.pop(0)
    # get the last node from the path
    node = path[-1]
    # if node is not in the explored ones
    if node not in explored:
      # get the neigbours of the node
      neighbours = graph[node]
      # go through all neighbour nodes
      for neighbour in neighbours:
        # construct a new path
        new_path = list(path)
        new_path.append(neighbour)
        # add it into the queue
        queue.append(new_path)
        # return path if neighbour is goal
        if neighbour == goal:
          return new_path

      # mark node as explored
      explored.append(node)

"""### **Bellman-Ford algorithm**"""

def bellman_ford(graph, source, dest):
  '''
  returns path between source and dest and the cost of this path
  dictionary consists of the nodes of the graph as keys and distances from the source node to each node of the graph as values
  predecessor is the graph in which nodes of graph are keys and nodes from which we reach them are values
  the source node doesn't have the predecessor since it is considered as the root
  graph: dictionary of nodes and its neighbours with weights
  '''
  distance, predecessors = {}, {}
  # initialize the distance from source to each node as infinity and the predecessor as None
  # the distance to the source is 0 since there is no distance to go from source to source
  for node in graph:
    distance[node], predecessors[node] = float('inf'), None
    distance[source] = 0
  
  for _ in range(len(graph) - 1):
    # for each node in graph dictionary
    for node in graph:
      # get the neighbours of the node
      for neighbour in graph[node]:
        # check if the distance from neighbour to the node is greater than distance from source to the neightbour
        if distance[neighbour] > distance[node] + graph[node][neighbour]:
          # if greater, then the distance from source to neighbour is the distance from source to node plus distance from node to neighbour
          # the predecessor of the neighbour is the node itself
          distance[neighbour], predecessors[neighbour] = distance[node] + graph[node][neighbour], node
  path=[]
  path.append(dest)
  cost=0
  while(dest!=source):
    predecessor=predecessors[dest]
    cost+=graph[predecessor][dest]
    dest=predecessor
    path.append(predecessor)
  return list(reversed(path)),cost

"""### **Dijkstra**"""

def dijsktra(G, source, dest, attr):
  '''
  dijkstra returns path between source and dest nodes and cost of this path
  visited is dictionary in which nodes are the keys and the weights of visiting node is the value
  predecessors is dictionary of predecessor for each node
  graph: is netwrokx.Graph
  '''
  visited = {source: 0}
  predecessors = {}

  nodes = list(G.nodes())

  # while nodes set is not empty
  while nodes: 
    # initialize variable min_node to None
    min_node = None
    # for each node in the nodes list
    for node in nodes:
      # if node is visited
      if node in visited:
        # if min_node is None, then min_node is the node
        if min_node is None:
          min_node = node
        # else if min_node is visited, then if node has been visited less than min_node
        elif visited[node] < visited[min_node]:
          min_node = node # # min_node is the node

    # if min_node is None, then break the while loop
    if min_node is None:
      break

    nodes.remove(min_node) # # remove min_node from nodes list
    current_weight = visited[min_node] # get the number of visiting min_node

    # for each edge for the given min_node
    for neigbour in list(G.neighbors(min_node)):
      # initialise weight to the sum of current_weight plus the distance of the edge
      weight = current_weight + G.edges[min_node, neigbour][attr]
       # if edge is not in visited or weight is less than number of visiting edge
      if neigbour not in visited or weight < visited[neigbour]:
        # assign the number of visiting the edge to the weight
        visited[neigbour] = weight
        #  then assign to the min_node as value
        predecessors[neigbour] = min_node

  path=[]
  path.append(dest)
  cost=0
  while(dest!=source): 
    predecessor=predecessors[dest]
    cost+=G.edges[predecessor, dest][attr]
    dest=predecessor
    path.append(predecessor)
  return list(reversed(path)),cost # return visited and path graph

"""##**Graph class**
Does the following:
* Constructing Adjacency Matrix
* Depth-First Search
* Minimum Spanning Tree(Kruskal's)
"""

# parent is dictionary which shows node and its parent
# rank is the dictionary which shows the node and how much of subnodes he has
parent = dict()
rank = dict()

class BasicGraph(object):
  """
  Graph is the base graph that all methods use.
  """
  def __init__(self, G, from_dict=None, from_list=None):
    """
    from_dict: creates graph for dictionary {n1:{n2:d} ...
    from_list: the same as for from_dict, but for list
    """
    self._nodes = {}
    self._edges = {}
    self._max_edge_value = 0

    if from_dict is not None:
      self.from_dict(from_dict)
    elif from_list is not None:
      self.from_list(from_list)

  def add_edge(self, node1, node2, value=1, bidirectional=False):
    """
    node1: start node in edge
    node2: end node in edge
    value: weight of edge (int or float)
    bidirectional: boolean. if bidirectional, means there is edges in both directions
    """
    if isinstance(value, (dict, list, tuple)):
      raise ValueError("value cannot be {}".format(type(value)))
    if node1 not in self._nodes:
      self.add_node(node1)
    if node2 not in self._nodes:
      self.add_node(node2)

    if node1 not in self._edges:
      self._edges[node1] = {}
    if node2 not in self._edges:
      self._edges[node2] = {}
    self._edges[node1][node2] = value
    if value > self._max_edge_value:
      self._max_edge_value = value
    if bidirectional:
      self._edges[node2][node1] = value

  def edge(self, node1, node2, default=None):
    """
    Returns the edge (node1, node2)
    Alias for g[node1][node2]
    node1: node
    node2: node
    default: returned value if edge doesn't exist.
    """
    try:
      return self._edges[node1][node2]
    except KeyError:
      return default

  def add_node(self, node, obj=None):
    """
    node: any hashable node.
    obj: any object that the node should refer to.
    PRO TIP: To retrieve the node obj use g.node(node)
    """
    self._nodes[node] = obj

  def node(self, node):
    """
    Retrieves the node object
    node: id of node in graph.
    """
    return self._nodes.get(node, None)
    
  def nodes(self, from_node=None, to_node=None, in_degree=None, out_degree=None):
    """
    Returns list of nodes
    from_node (optional) return nodes with edges from 'from_node'
    to_node (optional) returns nodes with edges into 'to_node'
    in_degree (optional) returns nodes with in_degree=N
    out_degree (optional) returns nodes with out_degree=N
    """
    inputs = sum([1 for i in (from_node, to_node, in_degree, out_degree) if i is not None])
    if inputs > 1:
      m = []
      a = (from_node, to_node, in_degree, out_degree)
      b = ("from_node", "to_node", "in_degree", "out_degree")
      for i in zip(a, b):
        if i is not None:
            m.append("{}={}".format(b, a))
      raise ValueError("nodes({}) has too many inputs. Pick one.".format(m))

    if inputs == 0:
      return list(self._nodes.keys())

    if from_node is not None:
      if self._edges.get(from_node, None) is not None:
          return [n2 for n2, v in self._edges[from_node].items()]
      return []

    if to_node is not None:
      return [n1 for n1, n2, d in self.edges() if n2 == to_node]

    if in_degree is not None:
      if not isinstance(in_degree, int) or in_degree < 0:
        raise ValueError("in_degree must be int >= 0")

      rev = {n: set() for n in self._nodes}
      for n1, n2, d in self.edges():
        rev[n2].add(n1)
      return [n for n, n_set in rev.items() if len(n_set) == in_degree]

    if out_degree is not None:
      if not isinstance(out_degree, int) or out_degree < 0:
        raise ValueError("out_degree must be int >= 0")

      rev = {n: set() for n in self._nodes}
      for n1, n2, d in self.edges():
        rev[n1].add(n2)
      return [n for n, n_set in rev.items() if len(n_set) == out_degree]

  def edges(self, path=None, from_node=None, to_node=None):
    """
    Returns list of edges
    path: (optional) list of nodes for which the edges are wanted.
    from_node: (optional) for which outgoing edges are returned.
    to_node: (optiona) for which incoming edges are returned.
    """
    inputs = sum([1 for i in (from_node, to_node, path) if i is not None])
    if inputs > 1:
      m = []
      a = (path, from_node, to_node)
      b = ("path", "from_node", "to_node")
      for i in zip(a, b):
        if i is not None:
          m.append("{}={}".format(b, a))
      raise ValueError("edges({}) has too many inputs. Pick one.".format(m))

    if path:
      if not isinstance(path, list):
        raise ValueError("expects a list")
      if len(path) < 2:
        raise ValueError("path of length 1 is not a path.")

      return [(path[ix], path[ix + 1], self._edges[path[ix]][path[ix + 1]])
              for ix in range(len(path )-1)]

    if from_node:
      if from_node in self._edges:
        return [(from_node, n2, self._edges[from_node][n2]) for n2 in self._edges[from_node]]
      else:
        return []

    if to_node:
      return [(n1, n2, self._edges[n1][n2])
              for n1 in self._edges
              for n2 in self._edges[n1]
              if n2 == to_node]

    return [(n1, n2, self._edges[n1][n2]) for n1 in self._edges for n2 in self._edges[n1]]

  def from_dict(self, dictionary):
    """
    Updates the graph from dictionary
    dictionary:
    d = {1: {2: 10, 3: 5},
          2: {4: 1, 3: 2},
          3: {2: 3, 4: 9, 5: 2},
          4: {5: 4},
          5: {1: 7, 4: 6}}
    G = Graph(from_dict=d)
    """
    assert isinstance(dictionary, dict)
    for n1, e in dictionary.items():
      if not e:
        self.add_node(n1)
      else:
        for n2, v in e.items():
          self.add_edge(n1, n2, v)

  def to_dict(self):
    """
    creates a nested dictionary from the graph.
    dict d[n1][n2] = distance
    """
    d = {}
    for n1, n2, dist in self.edges():
      if n1 not in d:
        d[n1] = {}
      d[n1][n2] = dist

    for n in self.nodes():
      if n not in d:
        d[n] = {}
    return d

  def from_list(self, links):
    """
    updates the graph from a list of links.
    links: list:
    links = [
        (1, 2, 18),
        (1, 3, 10),
        (2, 4, 7),
        (2, 5, 6),
        (3, 4, 2),
        (11,)      # node with no links.
    ]
    """
    assert isinstance(links, list)
    for item in links:
      assert isinstance(item, tuple)
      if len(item) == 3:
        self.add_edge(*item)
      else:
        self.add_node(item[0])

  def to_list(self):
    """ returns list of edges and nodes."""
    return self.edges() + [(i,) for i in self.nodes()]

  def adjacency_matrix(self):
    """
    Returns dictionary
    graph: of class BasicGraph
    Converts directed graph to an adjacency matrix.
    The distance from a node to itself is 0 and distance from a node to
    an unconnected node is defined to be infinity.
    There is may be path from a node to another via other nodes.
    Example:
        g = BasicGraph(from_dict=
            {1: {2: 3, 3: 8, 5: -4},
              2: {4: 1, 5: 7},
              3: {2: 4},
              4: {1: 2, 3: -5},
              5: {4: 6}})
        adjacency_matrix(g)
        {1: {1: 0, 2: 3, 3: 8, 4: inf, 5: -4},
          2: {1: inf, 2: 0, 3: inf, 4: 1, 5: 7},
          3: {1: inf, 2: 4, 3: 0, 4: inf, 5: inf},
          4: {1: 2, 2: inf, 3: -5, 4: 0, 5: inf},
          5: {1: inf, 2: inf, 3: inf, 4: 6, 5: 0}}
    """
    return {n1: {n2: 0 if n1 == n2 else self.edge(n1, n2, default=float('inf'))
                for n2 in self.nodes()}
            for n1 in self.nodes()}


  def all_pairs_shortest_paths(self):
    """
    Find the cost of the shortest path between every pair of nodes in a
    weighted graph. Uses the Floyd-Warshall algorithm.

    Floydâ€“Warshall algorithm (also known as Floyd's algorithm, the Royâ€“Warshall algorithm, the Royâ€“Floyd algorithm, or the WFI algorithm)
    is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles)
    """
    g = self.adjacency_matrix()
    assert isinstance(g, dict)
    nodes = g.keys()

    for n2 in nodes:
      g = {n1: {n3: min(g[n1][n3], g[n1][n2] + g[n2][n3])
                for n3 in nodes}
          for n1 in nodes}
    return g

  def depth_first_search(self, start, end):
    """
    Determine the path from start to end using 'depth first search' with backtracking
    Returns path as list of nodes
    start: start node
    end: end node
    """
    # check if start and end nodes are in the nodes list
    assert start in graph.nodes(), "start not in graph"
    assert end in graph.nodes(), "end not in graph"
    q = [start]
    path = []
    visited = set()
    # while queue is not empty
    while q:
      n1 = q.pop()
      visited.add(n1)
      path.append(n1)

      # if end is found
      if n1 == end:
        return path

      # go through nodes which are reached from n1 node
      for n2 in graph.nodes(from_node=n1):
        if n2 in visited:
          continue
        q.append(n2)
        break
      # if no break is encountered, then do else
      else:
        path.remove(n1)
        while not q and path:
          for n2 in graph.nodes(from_node=path[-1]):
            if n2 in visited:
              continue
            q.append(n2)
            break
          # if no break is encountered, then else
          else:
            path = path[:-1]
    return None  # if path was not found.

  def adjMatrix(self):
    '''
    Return adjacency matrix as 2D array
    '''
    sortedNodes=sorted(self.nodes())
    size=len(sortedNodes)
    matrix=np.zeros((size,size))
    # go 2 times through sorted nodes
    for node1 in sortedNodes:
      for node2 in sortedNodes:
        # get the edge between 2 nodes
        # if there is no edge, then return infinity
        res=self.edge(node1, node2, np.inf)
        # get the indeces of nodes in sorted nodes list
        index1=sortedNodes.index(node1)
        index2=sortedNodes.index(node2)
        # store the weight of the edge in matrix
        matrix[index1][index2]=res
    return matrix

  def make_set(self, node):
    '''
    Define the parent and the rank of node
    '''
    parent[node] = node
    rank[node] = 0

  def find(self, node):
    '''
    Find parent of the node
    '''
    if parent[node] != node:
      parent[node] = self.find(parent[node])
    return parent[node]

  def defineRoot(self, node1, node2):
    '''
    Define which of 2 nodes will be the root
    if node1 will have the rank greater than node2, it will be the root, since node1 will have more nodes under itself
    '''
    root1 = self.find(node1)
    root2 = self.find(node2)
    if root1 != root2:
      if rank[root1] > rank[root2]:
        parent[root2] = root1
      else:
        parent[root1] = root2
        if rank[root1] == rank[root2]: rank[root2] += 1

  def kruskal(self, sortBy='byName'):
    '''
    Apply kruskal's algorithm to determine the minimum spanning tree
    sortBy: defines by what to sort spanning tree
            byName, byCost, notSort
    '''
    sortedNodes=sorted(self.nodes())
    minimum_spanning_tree = set()
    # go through all nodes and determine their parent and rank
    for node in sortedNodes:
      self.make_set(node)
    edges = self.edges()
    edges=sorted(edges, key=lambda x:x[2])
    # for each edge in edges list, find the root between 2 nodes if their parents are not equal
    # if parents are not equal, set the root and add the edge to the minimum spanning tree
    for edge in edges:
      vertice1, vertice2, weight = edge
      if self.find(vertice1) != self.find(vertice2):
        self.defineRoot(vertice1, vertice2)
        minimum_spanning_tree.add(edge)

    # returns sorted minimum spanning tree depending on sortBy argument of function
    if sortBy=='byName':
      return sorted(minimum_spanning_tree)
    elif sortBy=='byCost':
      return sorted(minimum_spanning_tree, key=lambda item: item[2])
    elif sortBy=='notSort':
      return minimum_spanning_tree

"""## **Main**"""

dictionary=convertGraphToDictionary(G, 'Distance')
print("Bellman-Ford: ",bellman_ford(dictionary, 'BWI', 'CRP'))
print("BFS: ", bfs_shortest_path(dictionary, 'BWI', 'CRP'))

nodes,cost=dijsktra(G, 'BWI', 'CRP', 'Distance')
edges=[]
for i in range(len(nodes)-1):
  edges.append((nodes[i],nodes[i+1]))
plt.figure(figsize=(20,20))
position=nx.drawing.nx_pydot.graphviz_layout(G)
nx.draw_networkx(G, pos=position)
nx.draw_networkx(G, pos=position, nodelist=nodes, node_color='red', edgelist=edges, edge_color='red', width=1.5, node_size=600)
plt.savefig("dijkstra.png")

isinstance(dictionary, dict)

graph=BasicGraph(G,from_dict=dictionary) # constructing graph

dictionary=graph.all_pairs_shortest_paths()
dictionary

path=graph.depth_first_search('BWI', 'PBI')
print(path)
plt.figure(figsize=(20,20))
position=nx.drawing.nx_pydot.graphviz_layout(G)
nx.draw_networkx(G, pos=position)
nx.draw_networkx(G, pos=position, nodelist=path, node_color='red', edge_color='red')
plt.savefig("dfs.png")

len(graph.adjacency_matrix()['BWI'])

"""**Adjacency Matrix**"""

adj_matrix=graph.adjMatrix()
adj_matrix

"""**Kruskals Algorithm**"""

mstByName=graph.kruskal()
mstByName

mstByCost=graph.kruskal(sortBy='byCost')
mstByCost

mst=graph.kruskal(sortBy='notSort')
mst

Graph=nx.DiGraph()
for item in mst:
  node1,node2,weight=item
  Graph.add_nodes_from([node1,node2])
  Graph.add_edge(node1,node2, weight=weight)

"""### **Minimum Spanning Tree**"""

fig,ax=plt.subplots(figsize=(15,15))
pos=nx.drawing.nx_pydot.graphviz_layout(Graph)
nx.draw_networkx(Graph, pos=pos, ax=ax, font_size=10, node_size=400)
plt.savefig("mst.png")
